package com.maxvibes.plugin.service

import com.maxvibes.application.port.output.*
import com.maxvibes.domain.model.code.CodeElement
import com.maxvibes.domain.model.code.ElementKind
import com.maxvibes.domain.model.context.ContextRequest
import com.maxvibes.domain.model.context.GatheredContext
import com.maxvibes.domain.model.context.ProjectContext
import com.maxvibes.domain.model.modification.Modification
import com.maxvibes.shared.result.Result

/**
 * Мок LLM сервис для тестирования без реального API
 */
class MockLLMService : LLMService {

    override suspend fun chat(
        message: String,
        history: List<ChatMessageDTO>,
        context: ChatContext
    ): Result<ChatResponse, LLMError> {
        val response = buildString {
            appendLine("This is a mock response. I received your message:")
            appendLine()
            appendLine("> $message")
            appendLine()
            appendLine("In a real scenario, I would analyze your project and generate code modifications.")
            appendLine()
            appendLine("**Context received:**")
            appendLine("- Project: ${context.projectContext.name}")
            appendLine("- Files in context: ${context.gatheredFiles.size}")
            appendLine("- History messages: ${history.size}")
        }

        return Result.Success(
            ChatResponse(
                message = response,
                modifications = emptyList(),
                requestedFiles = emptyList()
            )
        )
    }

    override suspend fun planContext(
        task: String,
        projectContext: ProjectContext
    ): Result<ContextRequest, LLMError> {
        return Result.Success(
            ContextRequest(
                requestedFiles = emptyList(),
                reasoning = "Mock planning - no files requested"
            )
        )
    }

    override suspend fun generateModifications(
        task: String,
        gatheredContext: GatheredContext,
        projectContext: ProjectContext
    ): Result<List<Modification>, LLMError> {
        return Result.Success(emptyList())
    }

    override suspend fun generateModifications(
        instruction: String,
        context: LLMContext
    ): Result<List<Modification>, LLMError> {
        val modifications = mutableListOf<Modification>()

        context.relevantCode.forEach { element ->
            when {
                instruction.contains("add function", ignoreCase = true) ||
                        instruction.contains("добавь функцию", ignoreCase = true) -> {
                    modifications.add(
                        Modification.CreateElement(
                            targetPath = element.path,
                            elementKind = ElementKind.FUNCTION,
                            content = generateFunctionFromInstruction(instruction)
                        )
                    )
                }

                instruction.contains("toString", ignoreCase = true) -> {
                    modifications.add(
                        Modification.CreateElement(
                            targetPath = element.path,
                            elementKind = ElementKind.FUNCTION,
                            content = """
                                override fun toString(): String {
                                    return "${element.name}(...)"
                                }
                            """.trimIndent()
                        )
                    )
                }
            }
        }

        return if (modifications.isNotEmpty()) {
            Result.Success(modifications)
        } else {
            context.relevantCode.firstOrNull()?.let { element ->
                Result.Success(listOf(
                    Modification.CreateElement(
                        targetPath = element.path,
                        elementKind = ElementKind.FUNCTION,
                        content = """
                            fun generatedFunction(): String {
                                // TODO: Generated by MaxVibes
                                return "Hello from MaxVibes!"
                            }
                        """.trimIndent()
                    )
                ))
            } ?: Result.Success(emptyList())
        }
    }

    override suspend fun analyzeCode(
        question: String,
        codeElements: List<CodeElement>
    ): Result<AnalysisResponse, LLMError> {
        val summary = buildString {
            appendLine("## Code Analysis (Mock)")
            appendLine()
            appendLine("**Question:** $question")
            appendLine()
            appendLine("**Elements analyzed:** ${codeElements.size}")
            appendLine()
            appendLine("*This is a mock response.*")
        }

        return Result.Success(
            AnalysisResponse(
                answer = summary,
                suggestions = listOf("Consider adding documentation")
            )
        )
    }

    private fun generateFunctionFromInstruction(instruction: String): String {
        val funcName = extractName(instruction, "function", "функцию") ?: "newFunction"
        return """
            fun $funcName() {
                // TODO: Implement
            }
        """.trimIndent()
    }

    private fun extractName(instruction: String, vararg keywords: String): String? {
        val words = instruction.split(" ")
        for (keyword in keywords) {
            val idx = words.indexOfFirst { it.equals(keyword, ignoreCase = true) }
            if (idx >= 0 && idx < words.size - 1) {
                return words[idx + 1].filter { it.isLetterOrDigit() }
            }
        }
        return null
    }
}