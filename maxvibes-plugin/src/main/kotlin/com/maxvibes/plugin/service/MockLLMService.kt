package com.maxvibes.plugin.service

import com.maxvibes.application.port.output.*
import com.maxvibes.domain.model.code.CodeElement
import com.maxvibes.domain.model.code.ElementKind
import com.maxvibes.domain.model.context.ContextRequest
import com.maxvibes.domain.model.context.GatheredContext
import com.maxvibes.domain.model.context.ProjectContext
import com.maxvibes.domain.model.modification.Modification
import com.maxvibes.shared.result.Result

/**
 * Мок LLM сервис для тестирования без реального API
 */
class MockLLMService : LLMService {

    override suspend fun planContext(
        task: String,
        projectContext: ProjectContext
    ): Result<ContextRequest, LLMError> {
        // Mock: просто возвращаем пустой список файлов
        return Result.Success(
            ContextRequest(
                requestedFiles = emptyList(),
                reasoning = "Mock planning - no files requested"
            )
        )
    }

    override suspend fun generateModifications(
        task: String,
        gatheredContext: GatheredContext,
        projectContext: ProjectContext
    ): Result<List<Modification>, LLMError> {
        // Mock: создаём простую функцию
        return Result.Success(emptyList())
    }

    override suspend fun generateModifications(
        instruction: String,
        context: LLMContext
    ): Result<List<Modification>, LLMError> {

        // Простая логика для демонстрации
        val modifications = mutableListOf<Modification>()

        context.relevantCode.forEach { element ->
            when {
                instruction.contains("add function", ignoreCase = true) ||
                        instruction.contains("добавь функцию", ignoreCase = true) -> {
                    modifications.add(
                        Modification.CreateElement(
                            targetPath = element.path,
                            elementKind = ElementKind.FUNCTION,
                            content = generateFunctionFromInstruction(instruction)
                        )
                    )
                }

                instruction.contains("add property", ignoreCase = true) ||
                        instruction.contains("добавь свойство", ignoreCase = true) -> {
                    modifications.add(
                        Modification.CreateElement(
                            targetPath = element.path,
                            elementKind = ElementKind.PROPERTY,
                            content = generatePropertyFromInstruction(instruction)
                        )
                    )
                }

                instruction.contains("toString", ignoreCase = true) -> {
                    modifications.add(
                        Modification.CreateElement(
                            targetPath = element.path,
                            elementKind = ElementKind.FUNCTION,
                            content = """
                                override fun toString(): String {
                                    return "${element.name}(...)"
                                }
                            """.trimIndent()
                        )
                    )
                }
            }
        }

        return if (modifications.isNotEmpty()) {
            Result.Success(modifications)
        } else {
            // Если не поняли инструкцию — создаём дефолтную функцию
            context.relevantCode.firstOrNull()?.let { element ->
                Result.Success(listOf(
                    Modification.CreateElement(
                        targetPath = element.path,
                        elementKind = ElementKind.FUNCTION,
                        content = """
                            fun generatedFunction(): String {
                                // TODO: Generated by MaxVibes
                                // Instruction: $instruction
                                return "Hello from MaxVibes!"
                            }
                        """.trimIndent()
                    )
                ))
            } ?: Result.Success(emptyList())
        }
    }

    override suspend fun analyzeCode(
        question: String,
        codeElements: List<CodeElement>
    ): Result<AnalysisResponse, LLMError> {

        val summary = buildString {
            appendLine("## Code Analysis (Mock)")
            appendLine()
            appendLine("**Question:** $question")
            appendLine()
            appendLine("**Elements analyzed:** ${codeElements.size}")
            appendLine()

            codeElements.forEach { element ->
                appendLine("### ${element.kind}: ${element.name}")
                appendLine("- Path: `${element.path}`")
                appendLine("- Children: ${element.children.size}")
                appendLine()
            }

            appendLine("---")
            appendLine("*This is a mock response. Connect a real LLM for actual analysis.*")
        }

        return Result.Success(
            AnalysisResponse(
                answer = summary,
                suggestions = listOf(
                    "Consider adding documentation",
                    "Review naming conventions",
                    "Check for potential null safety issues"
                )
            )
        )
    }

    private fun generateFunctionFromInstruction(instruction: String): String {
        val funcName = extractName(instruction, "function", "функцию") ?: "newFunction"
        return """
            fun $funcName() {
                // TODO: Implement
            }
        """.trimIndent()
    }

    private fun generatePropertyFromInstruction(instruction: String): String {
        val propName = extractName(instruction, "property", "свойство") ?: "newProperty"
        return "val $propName: String = \"\""
    }

    private fun extractName(instruction: String, vararg keywords: String): String? {
        val words = instruction.split(" ")
        for (keyword in keywords) {
            val idx = words.indexOfFirst { it.equals(keyword, ignoreCase = true) }
            if (idx >= 0 && idx < words.size - 1) {
                return words[idx + 1].filter { it.isLetterOrDigit() }
            }
        }
        return null
    }
}